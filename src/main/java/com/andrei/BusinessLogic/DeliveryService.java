package com.andrei.BusinessLogic;

import com.andrei.DataAccess.ReportBillWriter;
import com.andrei.DataAccess.Serializer;
import com.andrei.Main;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * The delivery service class. Contains operations for clients, orders and menu items.
 * Implemented using the singleton design pattern, only a single instance of delivery service
 * is present at any time. getInstance() will simply grab it and return it to the caller.
 *
 * Has a list of clients which is deserialized from a file in the constructor. This list contains
 * all the information about the current registered clients and is queried whenever the interface
 * wants to add a new client.
 *
 * Has a list of menu items that can be composite or base products. This list is also deserialized
 * from a file at the beginning. Can also be loaded from a CSV using the populateProducts() method.
 *
 * Has a HashMap <Order, ArrayList<MenuItem>>. Order is the key for the map, array list of menu item
 * is the value. Many orders can hash to the same menu item list and saves space and time. Arraylist is
 * used because it has to be serializable. This map is used whenever someone wants the details of an order,
 * i.e. the ordered products.
 *
 * The class extends Observable and notifies its observers about any new orders that are inserted.
 *
 * @invariant isWellFormed()
 */
@SuppressWarnings("deprecation")
public class DeliveryService extends Observable implements IDeliveryServiceProcessing{
    private final List<Client> clients;
    private List<MenuItem> menuItems;

    private HashMap<Order, ArrayList<MenuItem>> orderDetails;
    private static DeliveryService deliveryService;

    /**
     * initialization using serialization. Private constructor because of singleton
     */
    private DeliveryService()
    {
        Serializer<Client> clientSerializer = new Serializer<>(Client.class);
        clients = clientSerializer.readFromFile();
        Serializer<MenuItem> menuItemSerializer = new Serializer<>(MenuItem.class);
        menuItems = menuItemSerializer.readFromFile();
        orderDetails = Serializer.readHashMap();
    }

    /**
     * @return instance of delivery service
     */
    public static DeliveryService getInstance()
    {
        if(deliveryService == null)
        {
            deliveryService = new DeliveryService();
        }
        return deliveryService;
    }

    /**
     * This method deletes all products from the table and replaces them with the products
     * from the CSV file located at absolute path. Starts with a stream of strings generated by
     * the Files.lines() method. First line is skipped because it contains just the names of the fields.
     * The call to map will map that line to a new base product that parses each fields from the string array.
     * The line is broken into pieces using string split on ",". For the name, the final character is removed
     * since for some bizarre reason the csv file has a final space for the name. After the mapping, we
     * now have a stream of base products. These are filtered to be distinct using the call to .distinct() which
     * will internally call the hash code and equals function to check if the items are identical. The unique key
     * is the name. Finally, the list is collected and stored.
     *
     * @pre absolutePath != null
     * @post isWellFormed() && list.size() > 0
     * @param absolutePath -> Absolute path of file that contains information
     */
    @Override
    public void populateProducts(String absolutePath)
    {
        //preconditions
        assert(absolutePath!= null);
        menuItems.clear();
        // what was before:
        //        try (Stream<String> stringStream = Files.lines(
        //                Path.of(Main.class.getResource(absolutePath).toURI())))
        try (Stream<String> stringStream = Files.lines(new File(absolutePath).toPath()))
        {
            menuItems = stringStream
                    .skip(1)
                    .map(line ->
                    {
                        String[] properties = line.split(",");
                        StringBuilder s = new StringBuilder(properties[0]);
                        s.deleteCharAt(s.length()-1);
                        String nameWithoutSpace = s.toString();
                        return new BaseProduct(
                                nameWithoutSpace,
                                Double.parseDouble(properties[1]),
                                Integer.parseInt(properties[2]),
                                Integer.parseInt(properties[3]),
                                Integer.parseInt(properties[4]),
                                Integer.parseInt(properties[5]),
                                Integer.parseInt(properties[6]));
                    })
                    .distinct()
                    .collect(Collectors.toList());
        }
        catch (IOException e) {
            System.err.println("Error when creating stream from " + absolutePath);
        }

        //post conditions
        assert(isWellFormed());
        assert(menuItems.size() > 0);
    }

    /**
     * This method removes a single menu item from the list of available ones
     *
     * @pre menuItems != null
     * @post isWellFormed() && list.size()@pre  == list.size()@post - 1
     * @param menuItem -> menuItem instance to be deleted
     */
    @Override
    public void removeMenuItem(MenuItem menuItem)
    {
        assert (menuItems != null);
        int sizePre = menuItems.size();
        menuItems.remove(menuItem);
        assert (isWellFormed());
        assert (sizePre == menuItems.size()+1);
    }

    /**
     * This method adds a single menu item at index 0.
     *
     * @pre menuItems != null
     * @post isWellFormed() && list.size()@pre  == list.size()@post + 1
     * @param menuItem -> menuItem instance to be added
     */
    @Override
    public void addMenuItem(MenuItem menuItem)
    {
        assert (menuItems != null);
        int sizePre = menuItems.size();
        menuItems.add(0,menuItem);
        assert (isWellFormed());
        assert (sizePre + 1 == menuItems.size());
    }
    /**
     * This method edits a single base product and updates the corresponding composites
     *
     * @pre menuItems != null
     * @post isWellFormed() && list.size()@pre  == list.size()@post
     * @param baseProduct -> base product details
     * @param updatedProduct -> updated product details
     */
    @Override
    public void editBaseProduct(BaseProduct updatedProduct, BaseProduct baseProduct)
    {
        assert (menuItems != null);
        int sizePre = menuItems.size();
        List<CompositeProduct> compositeProducts = getComposite();
        for (CompositeProduct compositeProduct : compositeProducts)
        {
            if(compositeProduct.getItems().contains(baseProduct))
            {
                compositeProduct.removeItem(baseProduct);
                compositeProduct.addItem(updatedProduct);
            }
        }
        int index = menuItems.indexOf(baseProduct);
        menuItems.set(index, updatedProduct);
        assert (isWellFormed());
        assert (sizePre == menuItems.size());
    }
    public List<CompositeProduct> getComposite()
    {
        List<CompositeProduct> compositeProducts = new ArrayList<>();
        for(MenuItem menuItem: menuItems)
        {
            if(menuItem instanceof CompositeProduct)
            {
                compositeProducts.add((CompositeProduct) menuItem);
            }
        }
        return compositeProducts;
    }

    /**
     * Grabs the keySet of the HashMap and returns it as a list of orders for easier processing.
     * @pre orderDetails != null
     * @post @nochange
     * @return list of all the orders
     */
    @Override
    public List<Order> getAllOrders() {
        assert (orderDetails != null);
        return orderDetails.keySet().stream().toList();
    }

    /**
     * This method will create an entry in the map with a link between the order and the menu items.
     * Once the insertion is finished, the set changed and notify methods. Thus, the employee(s) shall
     * be notified each time a new order is made. (behind the scenes, notify calls the hasChanged method,
     * so the employee(s) wouldn't be notified without the previous call to setChanged() )
     * @param order -> order to be inserted
     * @param menuItems -> mapped list of items
     */
    private void addOrder(Order order, ArrayList<MenuItem> menuItems)
    {
        this.orderDetails.put(order,menuItems);
        //notify all the observers
        this.setChanged();
        notifyObservers(order);
    }

    /**
     * Generates and order object with the required fields, calculating the total value of the order
     * by iterating through the given menu items. When a call to new Order() is made, internally the date
     * will be the current date precise to the millisecond. Once the order object is created, it is inserted into
     * the map of order details and a bill is written for it.
     *
     * @param client    -> client that made the order
     * @param menuItems -> list of menu items to be added to order
     */
    @Override
    public void addOrder(Client client, ArrayList<MenuItem> menuItems)
    {
        //preconditions
        assert (isWellFormed());
        assert (client != null);
        assert (menuItems.size() >= 1);
        int initialSizeOrder = getAllOrders().size();
        //calculate price
        double price = 0;
        for(MenuItem menuItem : menuItems)
        {
            price+= menuItem.getPrice();
        }
        Order order = new Order(client,price);
        addOrder(order,menuItems);
        new ReportBillWriter().generateBill(order);

        //post conditions
        assert(initialSizeOrder + 1 == getAllOrders().size());
        assert (orderDetails.get(order).containsAll(menuItems));
    }

    /**
     * Method to filter menu items for the first report. Filters are -1 if not applied.
     * The list is first sorted according to the filters using streams and the .filter() method
     * for the streams. The predicate is simple: checks if the filter is valid (different from -1)
     * then checks if the details are within the requested bounds. Next, the list is sorted based on
     * the keyword entered by the client.
     *
     * @pre isWellFormed()
     * @post updatedList.size() <= orders.size() && forEach menu item contains keyword
     * @param keyword -> search substring
     * @return a list of orders conforming to the filters
     */
    @Override
    public List<MenuItem> clientFilter(String keyword, double minRatingFilter, double maxRatingFilter,
                                       int minCaloriesFilter, int maxCaloriesFilter,
                                       int minProteinFilter, int maxProteinFilter,
                                       int minFatFilter, int maxFatFilter,
                                       int minSodiumFilter, int maxSodiumFilter,
                                       double minPriceFilter, double maxPriceFilter)
    {
        //preconditions
        assert (isWellFormed());
        List<MenuItem> updatedList = getMenuItems()
                .stream()
                .filter(menuItem -> {
                    if(minRatingFilter != -1) return menuItem.getRating() >= minRatingFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(maxRatingFilter != -1) return menuItem.getRating() <= maxRatingFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(minCaloriesFilter != -1) return menuItem.getCalories() >= minCaloriesFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(maxCaloriesFilter != -1) return menuItem.getCalories() <= maxCaloriesFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(minProteinFilter != -1) return menuItem.getProtein() >= minProteinFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(maxProteinFilter != -1) return menuItem.getProtein() <= maxProteinFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(minFatFilter != -1) return menuItem.getFat() >= minFatFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(maxFatFilter != -1) return menuItem.getFat() <= maxFatFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(minSodiumFilter != -1) return menuItem.getSodium() >= minSodiumFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(maxSodiumFilter != -1) return menuItem.getSodium() <= maxSodiumFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(minPriceFilter != -1) return menuItem.getPrice() >= minPriceFilter;
                    else return true;
                })
                .filter(menuItem -> {
                    if(maxPriceFilter != -1) return menuItem.getPrice() <= maxPriceFilter;
                    else return true;
                })
                .collect(Collectors.toList());
        if(!keyword.equals(""))
        {
            updatedList = updatedList
                    .stream()
                    .filter(menuItem ->
                            menuItem.getTitle().toLowerCase().contains(keyword.toLowerCase()))
                    .collect(Collectors.toList());
        }
        //post conditions
        assert (updatedList.size() <= menuItems.size());
        updatedList.forEach( menuItem ->
        {
            assert (menuItem.getTitle().toLowerCase().contains(keyword.toLowerCase()));
        });
        return updatedList;
    }

    /**
     * Filters orders between a given start time of day and a given end time of day. Same filtering
     * strategy as for client.
     * @pre isWellFormed()
     * @post updatedList.size() <= orders.size() && orders conforms to filters
     * @return -> list of filtered orders
     */
    @Override
    public List<Order> filterReport1(
            int minSecondFilter , int maxSecondFilter,
            int minMinuteFilter, int maxMinuteFilter,
            int minHourFilter, int maxHourFilter
    )
    {
        //preconditions
        assert(isWellFormed());
         List<Order> updatedOrders =  getAllOrders()
                .stream()
                .filter(order -> {
                    if(minSecondFilter != -1) return order.getDate().getSeconds() >= minSecondFilter;
                    else return true;
                })
                .filter(order -> {
                    if(maxSecondFilter != -1) return order.getDate().getSeconds() <= maxSecondFilter;
                    else return true;
                })
                .filter(order -> {
                    if(minMinuteFilter != -1) return order.getDate().getMinutes() >= minMinuteFilter;
                    else return true;
                })
                .filter(order -> {
                    if(maxMinuteFilter != -1) return order.getDate().getMinutes() <= maxMinuteFilter;
                    else return true;
                })
                .filter(order -> {
                    if(minHourFilter != -1) return order.getDate().getHours() >= minHourFilter;
                    else return true;
                })
                .filter(order -> {
                    if(maxHourFilter != -1) return order.getDate().getHours()<= maxHourFilter;
                    else return true;
                })
                .collect(Collectors.toList());
         //post conditions
         assert (updatedOrders.size() <= getAllOrders().size());
         for(Order order: updatedOrders)
         {
             assert minHourFilter == -1 || (order.getDate().getHours() >= minHourFilter);
             assert maxHourFilter == -1 || (order.getDate().getHours() <= maxHourFilter);
             assert minMinuteFilter == -1 || (order.getDate().getMinutes() >= minMinuteFilter);
             assert maxMinuteFilter == -1 || (order.getDate().getMinutes() <= maxMinuteFilter);
             assert minSecondFilter == -1 || (order.getDate().getSeconds() >= minSecondFilter);
             assert maxSecondFilter == -1 || (order.getDate().getSeconds() <= maxSecondFilter);
         }
         return updatedOrders;
    }

    /**
     * Filters to list that contains all the products ordered a minimum number of times so far.
     * Same filtering strategy as client filter, but this time for each menu item, a stream of orders is created
     * which counts the orders which contain the menu item. only menu item above min filter are counted.
     * @pre isWellFormed()
     * @post updatedList.size() <= menuItems.size() && menu items conforms to filter
     * @param minFilter -> minimum number of times an item has been ordered, by default 0.
     * @return -> list of updated menu items that have been ordered at least minFilter times
     */
    @Override
    public List<MenuItem> filterReport2(int minFilter)
    {
        isWellFormed();
        List<MenuItem> updatedList;
        if(minFilter != -1)
        {
            updatedList = menuItems.stream()
                    .filter(menuItem -> {
                        long found = getAllOrders().stream()
                                .filter(order -> orderDetails.get(order).contains(menuItem))
                                .count();
                        return found >= minFilter;
                    }).collect(Collectors.toList());
        }
        else updatedList = menuItems;
        assert (updatedList.size() <= menuItems.size());
        if(minFilter != -1)
        {
            updatedList.forEach( menuItem -> {
                long found = getAllOrders().stream()
                        .filter(order -> orderDetails.get(order).contains(menuItem))
                        .count();
                assert (found >= minFilter);
            });
        }
        return updatedList;
    }

    /**
     * Filters to a map that contains all the clients that have ordered a minimum number of times so far.
     * If the filters are not defined, all clients and orders are counted. Filtering is done by checking,
     * for each client if they have the required amount of orders with minPriceFilter value. If true, an entry will
     * be created in the map that maps the client to the number of times they have ordered.
     *
     * @pre isWellFormed()
     * @post map(client) >= minOrderFilter
     * @param minOrderFilter -> minimum number of orders for each client
     * @param minPriceFilter -> minimum price for each order
     * @return map of filtered clients and number of orders
     */
    @Override
    public HashMap<Client,Integer> filterReport3(int minOrderFilter, double minPriceFilter)
    {
        //preconditions
        assert(isWellFormed());
       HashMap<Client, Integer> map = new HashMap<>();
       if(minOrderFilter != -1 && minPriceFilter != -1)
       {
           clients.forEach(
                   client -> {
                       long count = getAllOrders().stream()
                               .filter(order -> order.getClient().equals(client))
                               .filter(order -> order.getPrice() >= minPriceFilter)
                               .count();
                       if(count >= minOrderFilter) map.put(client,(int)count);
                   }
           );
       }
       else if(minOrderFilter != -1)
       {
           clients.forEach(
                   client -> {
                       long count = getAllOrders().stream()
                               .filter(order -> order.getClient().equals(client))
                               .count();
                       if(count >= minOrderFilter) map.put(client,(int)count);
                   }
           );
       }
       else if(minPriceFilter != -1)
       {
           clients.forEach(
                   client -> {
                       long count = getAllOrders().stream()
                               .filter(order -> order.getClient().equals(client))
                               .filter(order -> order.getPrice() >= minPriceFilter)
                               .count();
                       map.put(client,(int)count);
                   }
           );
       }
       else
       {
           clients.forEach(
                   client -> {
                       long count = getAllOrders().stream()
                               .filter(order -> order.getClient().equals(client))
                               .count();
                       map.put(client,(int)count);
                   }
           );
       }
       if(minOrderFilter != -1)
       {
           List<Client> clients = map.keySet().stream().toList();
           clients.forEach(client -> {
               assert(map.get(client) >= minOrderFilter);
           });
       }
       return map;
    }

    /**
     * Filters to a map that contains all the products ordered within
     * a specific day and the number of times they have been ordered.
     *
     * If the date parameter is not null, the orders are filtered so that
     * only the required date is present. Then they are filtered so that they
     * contain the menuitem, and then counted. This count is sent to a hash map
     * between menu item and a key which represents the number of times they have been ordered.
     *
     * @pre isWellFormed()
     * @post each menu item must be found in at least one order
     * @param localDate -> date for report
     * @return -> map of menu items and the times they have been ordered on that day
     */
    @Override
    public HashMap<MenuItem,Integer> filterReport4(LocalDate localDate)
    {
        //precondition
        isWellFormed();
        HashMap<MenuItem, Integer> map = new HashMap<>();
        if(localDate == null)
        {
            menuItems.forEach(
                    menuItem ->
                    {
                        long count = getAllOrders()
                                .stream()
                                .filter(order -> orderDetails.get(order).contains(menuItem))
                                .count();
                        if(count != 0)
                        {
                            map.put(menuItem,(int)count);
                        }
                    }
            );
        }
        else
        {
            menuItems.forEach(
                    menuItem ->
                    {
                        long count = getAllOrders()
                                .stream()
                                .filter(order ->
                                {
                                    Calendar calendar  = Calendar.getInstance();
                                    calendar.setTime(order.getDate());
                                    return calendar.get(Calendar.YEAR) == localDate.getYear()
                                            && calendar.get(Calendar.MONTH) == localDate.getMonth().getValue() - 1
                                            && calendar.get(Calendar.DAY_OF_MONTH) == localDate.getDayOfMonth();
                                })
                                .filter(order -> orderDetails.get(order).contains(menuItem))
                                .count();
                        if(count != 0)
                        {
                            map.put(menuItem,(int)count);
                        }
                    }
            );
        }
        //post condition
        map.keySet().forEach(
                menuItem -> {
                    boolean found = false;
                    for(Order order: getAllOrders())
                    {
                        if(orderDetails.get(order).contains(menuItem))
                        {
                            found = true;
                            break;
                        }
                    }
                    assert (found);
                }
        );
        return map;
    }

    /**
     * Checks whether the class is in a valid state. Checks for not null,
     * uniqueness of products and clients and if the composite products
     * are built properly.
     * @return true if the class is well-formed, false otherwise
     */
    private boolean isWellFormed()
    {
        //check if delivery service instance is different from null
        if(deliveryService == null) return false;
        //check if all lists are not null
        if(clients == null || menuItems == null || orderDetails == null) return false;
        //check if there are multiple clients with the same username
        for(int i=0; i < clients.size() - 1; i++)
        {
            for (int j= i+1; j < clients.size(); j++)
            {
                if(clients.get(i).getUsername().equals(clients.get(j).getUsername())) return false;
            }
        }
        //check if there are multiple menu items with the same title
        for(int i=0; i < menuItems.size() - 1; i++)
        {
            for (int j= i+1; j < menuItems.size(); j++)
            {
                if(menuItems.get(i).equals(menuItems.get(j))) return false;
            }
        }
        //check if there are multiple equal orders
        for(int i=0; i < getAllOrders().size() - 1; i++)
        {
            for (int j= i+1; j < getAllOrders().size(); j++)
            {
                if(getAllOrders().get(i).equals(getAllOrders().get(j))) return false;
            }
        }
        //check if all composite children are in menu items
        List<CompositeProduct> compositeProducts = getComposite();
        for (CompositeProduct compositeProduct: compositeProducts)
        {
            List<MenuItem> otherItems = compositeProduct.getItems();
            if(!menuItems.containsAll(otherItems)) return false;
        }
        //check if composite products are built properly (price)
        for (CompositeProduct compositeProduct: compositeProducts)
        {
            List<MenuItem> otherItems = compositeProduct.getItems();
            double sum = 0;
            for(MenuItem menuItem: otherItems)
            {
                sum += menuItem.getPrice();
            }
            if(sum!= compositeProduct.computePrice()) return false;
        }
        return true;
    }


    //getter and setter
    public List<Client> getClients() {
        return clients;
    }

    public List<MenuItem> getMenuItems() {
        return menuItems;
    }

    public HashMap<Order, ArrayList<MenuItem>> getOrderDetails() {
        return orderDetails;
    }
    public void setOrderDetails(HashMap<Order, ArrayList<MenuItem>> orderDetails) {
        this.orderDetails = orderDetails;
    }
}
